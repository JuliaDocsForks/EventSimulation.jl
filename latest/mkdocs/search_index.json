{
    "docs": [
        {
            "location": "/", 
            "text": "EventSimulation.jl\n\n\nAn event based Discrete Event Simulation engine for Julia.\n\n\nIntended as a support library for teaching basic principles of Discrete Event Simulation.\n\n\n\n\nPackage features\n\n\n\n\nregister/interrupt execution of events\n\n\nresource (continuous homogenous good) reservoir\n\n\nqueue (arbitrary objects) reservoir\n\n\n\n\n\n\nExamples\n\n\nA quick start tutorial can be found \nhere\n.\n\n\nExamples contained in \n/examples/\n directory:\n\n\n\n\nmms_example.jl\n: comparison of several implementations of M/M/s queue\n\n\nmm1_example.jl\n: basic implementation of M/M/1 queue with use of monitor\n\n\nbank_renege_1.jl\n: bank renege model (reimplementation of SimPy example)\n\n\nbank_renege_2.jl\n: bank renege model (reimplementation of SimPy example)\n\n\nmovie_renege.jl\n: movie renege model (reimplementation of SimPy example)\n\n\nfaxqueue.jl\n: a two-stage fax queue model; adaptation of Nelson (2013): \nFoundations and Methods of Stochastic Simulation\n, chap. 4.6, example\n\n\n\n\nThe models that are reimplemnetation of SimPy run an order of magnitude (\n20x) faster than in \nSimPy\n or \nSimJulia\n process oriented DES engines.\n\n\n\n\nQuck overview of EventSimulation functionality\n\n\n\n\n\n\nGeneral functionality\n\n\n\n\nAction\n: information that a given function should be executed at given time\n\n\nAbstractState\n: abstract type used for holding global simulation state\n\n\nEmptyState\n: simplest empty concrete subtype of \nAbstractState\n\n\nScheduler\n\n\nregister!\n: puts \nAction\n into \nScheduler\n queue\n\n\nrepeat_register!\n: puts \nAction\n into \nScheduler\n queue repeatedly\n\n\nbulk_register!\n: puts \nAction\n into \nScheduler\n that will affect multiple objects\n\n\nrepeat_bulk_register!\n: puts \nAction\n into \nScheduler\n that will affect multiple objects repeatedly\n\n\ninterrupt!\n: removes one given event from \nScheduler\n queue\n\n\nterminate!\n: removes all events from \nScheduler\n queue\n\n\ngo!\n: executes the simulation\n\n\n\n\nContainers\n\n\n\n\n\n\nAbstractReservoir\n: abstract type for defining reservoirs\n\n\n\n\nSimResource\n: reservoir for divisible and homogeneous matter\n\n\nResourceRequest\n: information about request for a resource\n\n\nSimQueue\n: reservoir for objects having unique identity\n\n\nrequest!\n: registers demand for a resource/object\n\n\nwaive!\n: remove registered request from waiting list\n\n\nprovide!\n: add resource/object to reservoir (or remove resource from \nSimResource\n)\n\n\nwithdraw!\n: remove object from \nSimQueue\n\n\n\n\nUtilities\n\n\n\n\n\n\nPriorityTime\n: custom subtype of \nReal\n providing additional attribute \npriority\n to normal time. Useful for giving execution priority of events happening at the same time.\n\n\n\n\n\n\n\n\n\n\n\n\nDocumentation Types and functions defined in EventSimulation package\n\n\nEventSimulation\nAction\nAbstractState\nEmptyState\nScheduler\nregister!\nrepeat_register!\nbulk_register!\nrepeat_bulk_register!\ninterrupt!\nterminate!\ngo!\nAbstractReservoir\nSimResource\nResourceRequest\nSimQueue\ndispatch!\nrequest!\nwaive!\nprovide!\nwithdraw!\nPriorityTime", 
            "title": "Home"
        }, 
        {
            "location": "/#eventsimulationjl", 
            "text": "An event based Discrete Event Simulation engine for Julia.  Intended as a support library for teaching basic principles of Discrete Event Simulation.", 
            "title": "EventSimulation.jl"
        }, 
        {
            "location": "/#package-features", 
            "text": "register/interrupt execution of events  resource (continuous homogenous good) reservoir  queue (arbitrary objects) reservoir", 
            "title": "Package features"
        }, 
        {
            "location": "/#examples", 
            "text": "A quick start tutorial can be found  here .  Examples contained in  /examples/  directory:   mms_example.jl : comparison of several implementations of M/M/s queue  mm1_example.jl : basic implementation of M/M/1 queue with use of monitor  bank_renege_1.jl : bank renege model (reimplementation of SimPy example)  bank_renege_2.jl : bank renege model (reimplementation of SimPy example)  movie_renege.jl : movie renege model (reimplementation of SimPy example)  faxqueue.jl : a two-stage fax queue model; adaptation of Nelson (2013):  Foundations and Methods of Stochastic Simulation , chap. 4.6, example   The models that are reimplemnetation of SimPy run an order of magnitude ( 20x) faster than in  SimPy  or  SimJulia  process oriented DES engines.", 
            "title": "Examples"
        }, 
        {
            "location": "/#quck-overview-of-eventsimulation-functionality", 
            "text": "General functionality   Action : information that a given function should be executed at given time  AbstractState : abstract type used for holding global simulation state  EmptyState : simplest empty concrete subtype of  AbstractState  Scheduler  register! : puts  Action  into  Scheduler  queue  repeat_register! : puts  Action  into  Scheduler  queue repeatedly  bulk_register! : puts  Action  into  Scheduler  that will affect multiple objects  repeat_bulk_register! : puts  Action  into  Scheduler  that will affect multiple objects repeatedly  interrupt! : removes one given event from  Scheduler  queue  terminate! : removes all events from  Scheduler  queue  go! : executes the simulation   Containers    AbstractReservoir : abstract type for defining reservoirs   SimResource : reservoir for divisible and homogeneous matter  ResourceRequest : information about request for a resource  SimQueue : reservoir for objects having unique identity  request! : registers demand for a resource/object  waive! : remove registered request from waiting list  provide! : add resource/object to reservoir (or remove resource from  SimResource )  withdraw! : remove object from  SimQueue   Utilities    PriorityTime : custom subtype of  Real  providing additional attribute  priority  to normal time. Useful for giving execution priority of events happening at the same time.", 
            "title": "Quck overview of EventSimulation functionality"
        }, 
        {
            "location": "/#documentation-types-and-functions-defined-in-eventsimulation-package", 
            "text": "EventSimulation\nAction\nAbstractState\nEmptyState\nScheduler\nregister!\nrepeat_register!\nbulk_register!\nrepeat_bulk_register!\ninterrupt!\nterminate!\ngo!\nAbstractReservoir\nSimResource\nResourceRequest\nSimQueue\ndispatch!\nrequest!\nwaive!\nprovide!\nwithdraw!\nPriorityTime", 
            "title": "Documentation Types and functions defined in EventSimulation package"
        }, 
        {
            "location": "/tutorial/", 
            "text": "EventSimulation Tutorial\n\n\n\n\nInstallation\n\n\nIn REPL run \nPkg.add(\"EventSimulation\")\n to install the package and next \nusing EventSimulation\n to start using it.\n\n\n\n\nFirst simulation\n\n\nThis is a bare minimum simulation using EventSimulation:\n\n\nusing EventSimulation\n\nfunction arrived(s)\n    t = s.now\n    println(\nArrived at \n, s.now)\n    register!(s, x -\n println(\nLeft at $(x.now) that arrived at $t\n), 1.5)\nend\n\ns = Scheduler()\nfor t in 1.0:5.0\n    register!(s, arrived, t)\nend\n\ngo!(s)\n\n\n\n\nIn this example five customers arrive at times 1, 2, ..., 5 and stay in the system for 1.5 time units. Observe that in \narrived\n we use a closure to define anonymous function that is registered. In its body \nx.now\n will be taken from the state of the scheduler when the anonymous function is invoked but \nt\n is fixed in enclosing scope of \narrived\n function as the time of the arrival.\n\n\nExercise\n: test what happens if you replace \n$t\n with \n$(s.now)\n in the anonymous function. What is the reason of this behavior?\n\n\nWhen using EventSimulation working with closures is often the simplest way to develop a simulation so it is important that you understand this example.", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#eventsimulation-tutorial", 
            "text": "", 
            "title": "EventSimulation Tutorial"
        }, 
        {
            "location": "/tutorial/#installation", 
            "text": "In REPL run  Pkg.add(\"EventSimulation\")  to install the package and next  using EventSimulation  to start using it.", 
            "title": "Installation"
        }, 
        {
            "location": "/tutorial/#first-simulation", 
            "text": "This is a bare minimum simulation using EventSimulation:  using EventSimulation\n\nfunction arrived(s)\n    t = s.now\n    println( Arrived at  , s.now)\n    register!(s, x -  println( Left at $(x.now) that arrived at $t ), 1.5)\nend\n\ns = Scheduler()\nfor t in 1.0:5.0\n    register!(s, arrived, t)\nend\n\ngo!(s)  In this example five customers arrive at times 1, 2, ..., 5 and stay in the system for 1.5 time units. Observe that in  arrived  we use a closure to define anonymous function that is registered. In its body  x.now  will be taken from the state of the scheduler when the anonymous function is invoked but  t  is fixed in enclosing scope of  arrived  function as the time of the arrival.  Exercise : test what happens if you replace  $t  with  $(s.now)  in the anonymous function. What is the reason of this behavior?  When using EventSimulation working with closures is often the simplest way to develop a simulation so it is important that you understand this example.", 
            "title": "First simulation"
        }
    ]
}