{
    "docs": [
        {
            "location": "/", 
            "text": "EventSimulation.jl\n\n\nAn event based Discrete Event Simulation engine for Julia.\n\n\nIntended as a support library for teaching basic principles of Discrete Event Simulation.\n\n\n\n\nPackage features\n\n\n\n\nregister/interrupt execution of events\n\n\nresource (continuous homogenous good) reservoir\n\n\nqueue (arbitrary objects) reservoir\n\n\n\n\n\n\nExamples\n\n\nA quick start tutorial can be found \nhere\n.\n\n\nExamples contained in \n/examples/\n directory:\n\n\n\n\nmms_example.jl\n: comparison of several implementations of M/M/s queue\n\n\nmm1_example.jl\n: basic implementation of M/M/1 queue with use of monitor\n\n\nbank_renege_1.jl\n: bank renege model (reimplementation of SimPy example)\n\n\nbank_renege_2.jl\n: bank renege model (reimplementation of SimPy example)\n\n\nmovie_renege.jl\n: movie renege model (reimplementation of SimPy example)\n\n\nfaxqueue.jl\n: a two-stage fax queue model; adaptation of Nelson (2013): \nFoundations and Methods of Stochastic Simulation\n, chap. 4.6, example\n\n\n\n\nThe models that are reimplemnetation of SimPy run an order of magnitude (\n20x) faster than in \nSimPy\n or \nSimJulia\n process oriented DES engines.\n\n\n\n\nQuck overview of EventSimulation functionality\n\n\nGeneral functionality\n\n\n\n\nAction\n: information that a given function should be executed at given time\n\n\nAbstractState\n: abstract type used for holding global simulation state\n\n\nEmptyState\n: simplest empty concrete subtype of \nAbstractState\n\n\nScheduler\n: central object in the library jused to store information about event queue\n\n\nregister!\n: puts \nAction\n into \nScheduler\n queue\n\n\nrepeat_register!\n: puts \nAction\n into \nScheduler\n queue repeatedly\n\n\nbulk_register!\n: puts \nAction\n into \nScheduler\n that will affect multiple objects\n\n\nrepeat_bulk_register!\n: puts \nAction\n into \nScheduler\n that will affect multiple objects repeatedly\n\n\ninterrupt!\n: removes one given event from \nScheduler\n queue\n\n\nterminate!\n: removes all events from \nScheduler\n queue\n\n\ngo!\n: executes the simulation\n\n\n\n\nContainers\n\n\n\n\nAbstractReservoir\n: abstract type for defining reservoirs\n\n\nSimResource\n: reservoir for divisible and homogeneous matter\n\n\nResourceRequest\n: information about request for a resource\n\n\nSimQueue\n: reservoir for objects having unique identity\n\n\nrequest!\n: registers demand for a resource/object\n\n\nwaive!\n: remove registered request from waiting list\n\n\nprovide!\n: add resource/object to reservoir (or remove resource from \nSimResource\n)\n\n\nwithdraw!\n: remove object from \nSimQueue\n\n\n\n\nUtilities\n\n\n\n\nPriorityTime\n: custom subtype of \nReal\n providing additional attribute \npriority\n to normal time. Useful for giving execution priority of events happening at the same time.\n\n\n\n\nFull documentation of types and functions defined in EventSimulation package can be found \nhere\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#eventsimulationjl", 
            "text": "An event based Discrete Event Simulation engine for Julia.  Intended as a support library for teaching basic principles of Discrete Event Simulation.", 
            "title": "EventSimulation.jl"
        }, 
        {
            "location": "/#package-features", 
            "text": "register/interrupt execution of events  resource (continuous homogenous good) reservoir  queue (arbitrary objects) reservoir", 
            "title": "Package features"
        }, 
        {
            "location": "/#examples", 
            "text": "A quick start tutorial can be found  here .  Examples contained in  /examples/  directory:   mms_example.jl : comparison of several implementations of M/M/s queue  mm1_example.jl : basic implementation of M/M/1 queue with use of monitor  bank_renege_1.jl : bank renege model (reimplementation of SimPy example)  bank_renege_2.jl : bank renege model (reimplementation of SimPy example)  movie_renege.jl : movie renege model (reimplementation of SimPy example)  faxqueue.jl : a two-stage fax queue model; adaptation of Nelson (2013):  Foundations and Methods of Stochastic Simulation , chap. 4.6, example   The models that are reimplemnetation of SimPy run an order of magnitude ( 20x) faster than in  SimPy  or  SimJulia  process oriented DES engines.", 
            "title": "Examples"
        }, 
        {
            "location": "/#quck-overview-of-eventsimulation-functionality", 
            "text": "General functionality   Action : information that a given function should be executed at given time  AbstractState : abstract type used for holding global simulation state  EmptyState : simplest empty concrete subtype of  AbstractState  Scheduler : central object in the library jused to store information about event queue  register! : puts  Action  into  Scheduler  queue  repeat_register! : puts  Action  into  Scheduler  queue repeatedly  bulk_register! : puts  Action  into  Scheduler  that will affect multiple objects  repeat_bulk_register! : puts  Action  into  Scheduler  that will affect multiple objects repeatedly  interrupt! : removes one given event from  Scheduler  queue  terminate! : removes all events from  Scheduler  queue  go! : executes the simulation   Containers   AbstractReservoir : abstract type for defining reservoirs  SimResource : reservoir for divisible and homogeneous matter  ResourceRequest : information about request for a resource  SimQueue : reservoir for objects having unique identity  request! : registers demand for a resource/object  waive! : remove registered request from waiting list  provide! : add resource/object to reservoir (or remove resource from  SimResource )  withdraw! : remove object from  SimQueue   Utilities   PriorityTime : custom subtype of  Real  providing additional attribute  priority  to normal time. Useful for giving execution priority of events happening at the same time.   Full documentation of types and functions defined in EventSimulation package can be found  here .", 
            "title": "Quck overview of EventSimulation functionality"
        }, 
        {
            "location": "/tutorial/", 
            "text": "EventSimulation Tutorial\n\n\n\n\nInstallation\n\n\nIn REPL run \nPkg.add(\"EventSimulation\")\n to install the package and next \nusing EventSimulation\n to start using it.\n\n\n\n\nFirst simulation\n\n\nThis is a bare minimum simulation using EventSimulation:\n\n\nusing EventSimulation\n\nfunction arrival(s)\n    t = s.now\n    println(\nArrived at \n, s.now)\n    register!(s, x -\n println(\nLeft at $(x.now) that arrived at $t\n), 1.5)\nend\n\ns = Scheduler()\nfor t in 1.0:5.0\n    register!(s, arrival, t)\nend\n\ngo!(s)\n\n\n\n\nIn this example five customers arrive at times 1, 2, ..., 5 and stay in the system for 1.5 time units. Observe that in \narrival\n we use a closure to define anonymous function that is registered. In its body \nx.now\n will be taken from the state of the scheduler when the anonymous function is invoked but \nt\n is fixed in enclosing scope of \narrival\n function as the time of the arrival.\n\n\nExercise\n: \nTest what happens if you replace \n$t\n with \n$(s.now)\n in the anonymous function. What is the reason of this behavior?\n\n\nWhen using EventSimulation working with closures is often the simplest way to develop a simulation so it is important that you understand this example.\n\n\n\n\nDefining infinite source of events\n\n\nNow we add an infinite stream of customers arriving to the system:\n\n\nusing EventSimulation\n\nfunction arrival(s)\n    t = s.now\n    println(\nArrived at \n, s.now)\n    register!(s, x -\n println(\nLeft at $(x.now) that arrived at $t\n), 1.5)\nend\n\ns = Scheduler()\nrepeat_register!(s, arrival, x -\n 1.0)\n\ngo!(s, 7)\n\n\n\n\n\nIn this example we show how \narrival\n function can be scheduled to be repeatedly put into event queue in time deltas defined by anonymous function \nx -\n 1.0\n.\n\n\nAslo observe that we have passed second argument \n7\n to function \ngo!\n which will force unconditional termination of the simulation after this moment.\n\n\nExercise\n: \nThink what would happen if the termination time would be omitted in the expression \ngo!(s, 7)\n. How you could use function \nterminate!\n inside definition of \narrival\n to get a similar effect. What would be the difference?\n\n\n\n\nDefining custom simulation state\n\n\nNow let us add a simple counter of number of customers in the system:\n\n\nusing EventSimulation\n\nmutable struct CounterState \n: AbstractState\n    count::Int\nend\n\nfunction arrival(s)\n    function departure(x)\n        x.state.count -= 1\n        println(\nLeft at $(x.now) that arrived at $t and left \n,\n                x.state.count, \n other customers\n)\n    end\n\n    t = s.now\n    println(\nArrived at \n, s.now, \n and met \n, s.state.count, \n other customers\n)\n    register!(s, departure, 1.0)\n    s.state.count += 1\nend\n\ns = Scheduler(CounterState(0))\n\nsrand(1)\nrepeat_register!(s, arrival, x -\n rand())\ngo!(s, 10)\n\n\n\n\nObserve that all functions in EventSimulation receive \nScheduler\n as an argument and therefore they have acces to current simulation time and simulation state.\n\n\nAdditionally we have changed customer arrival behavior to random.\n\n\nExercise\n: \nTry changing customer's arrival rate to the exponential distribution using \nrandexp\n function. Next change time in system distribution to the Gamma distribution. You can find it in \nDistributions\n package.\n\n\n\n\nMonitoring simulation\n\n\nLet us calculate how many customers are present in the above system using custom \nmonitor\n.\n\n\nusing EventSimulation\n\nmutable struct CounterState \n: AbstractState\n    count::Int\n    total_time::Float64\n    customer_time::Float64\nend\n\nfunction arrival(s)\n    register!(s, departure, 1.0)\n    s.state.count += 1\nend\n\nfunction departure(s)\n    s.state.count -= 1\nend\n\nfunction monitor(s, \u0394)\n    s.state.total_time += \u0394\n    s.state.customer_time += \u0394 * s.state.count\nend\n\ncs = CounterState(0, 0.0, 0.0)\ns = Scheduler(cs, Float64, monitor)\n\nsrand(1)\nrepeat_register!(s, arrival, x -\n rand())\ngo!(s, 100_000)\nprintln(\nAverage number of customers in a system is \n,\n        cs.customer_time/cs.total_time)\n\n\n\n\nObserve that \nmonitor\n usually will modify simulation state to gather the simulation statistics. Other approaches could use global variables or variables defined in closure of \nmonitor\n, but using simulation state is the recommended approach.\n\n\nExercise\n: \nThink if the obtained result is in line with \nLittle's law\n. Try changing arrival rate and time in the system to check it. As a more advanced exercise make \nmonitor\n collect data only when simulation time is greater or equal than 100 (i.e. discarding simulation burn-in period).\n\n\n\n\nIntroduction to resources\n\n\nNow we will consider two streams of agents. Supplier provides one unit of good every one unit of time. There are customers that arrive randomly and want to buy a random amount of good. Maximally two customers .\n\n\nusing EventSimulation\n\nmutable struct GoodState \n: AbstractState\n    good::SimResource{Float64}\nend\n\nfunction delivery(s)\n    provide!(s, s.state.good, 1.0)\n    print_with_color(:green, \nDelivered 1.0 at \n, s.now, \n\\n\n)\nend\n\nfunction customer(s)\n    function leave(x)\n        println(\nLeft at \n, x.now, \n with quantity \n, round(demand, 4))\n    end\n    demand = rand()\n    print(\nArrived at \n, round(s.now, 4), \n with demand \n, round(demand, 4))\n    if !request!(s, s.state.good, demand, leave)[1]\n        print_with_color(:red, \n but line was too long and left with nothing\\n\n)\n    else\n        println(\n and went into a queue\n)\n    end\nend\n\nfunction balance(s)\n    info(\nAmount of good in storage: \n,\n         round(s.state.good.quantity, 4), \n at time \n, s.now)\nend\n\ns = Scheduler(GoodState(SimResource{Float64}(max_requests=2)))\n\nsrand(1)\nrepeat_register!(s, delivery, x -\n 1.0)\nrepeat_register!(s, customer, x -\n rand())\nrepeat_register!(s, balance, x -\n x.now == 0 ? 1.000001 : 1.0)\ngo!(s, 5)\n\n\n\n\nObserve that fulfillment of pending requests by \nSimResource\n is immediate. This means that the amount is passed to a request from the container before the request event executed.\n\n\nExercise\n: \nWe have used a fixed value of \n0.000001\n as an increment over an integer number to invoke \nbalance\n. Rewrite the example using \nPriorityTime\n type in such a way that \nbalance\n is invoked at integer times but with priority low enough.\n\n\nThis is the end of this introductory tutorial. More advanced features are covered in examples contained in \n/examples/\n directory.", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#eventsimulation-tutorial", 
            "text": "", 
            "title": "EventSimulation Tutorial"
        }, 
        {
            "location": "/tutorial/#installation", 
            "text": "In REPL run  Pkg.add(\"EventSimulation\")  to install the package and next  using EventSimulation  to start using it.", 
            "title": "Installation"
        }, 
        {
            "location": "/tutorial/#first-simulation", 
            "text": "This is a bare minimum simulation using EventSimulation:  using EventSimulation\n\nfunction arrival(s)\n    t = s.now\n    println( Arrived at  , s.now)\n    register!(s, x -  println( Left at $(x.now) that arrived at $t ), 1.5)\nend\n\ns = Scheduler()\nfor t in 1.0:5.0\n    register!(s, arrival, t)\nend\n\ngo!(s)  In this example five customers arrive at times 1, 2, ..., 5 and stay in the system for 1.5 time units. Observe that in  arrival  we use a closure to define anonymous function that is registered. In its body  x.now  will be taken from the state of the scheduler when the anonymous function is invoked but  t  is fixed in enclosing scope of  arrival  function as the time of the arrival.  Exercise :  Test what happens if you replace  $t  with  $(s.now)  in the anonymous function. What is the reason of this behavior?  When using EventSimulation working with closures is often the simplest way to develop a simulation so it is important that you understand this example.", 
            "title": "First simulation"
        }, 
        {
            "location": "/tutorial/#defining-infinite-source-of-events", 
            "text": "Now we add an infinite stream of customers arriving to the system:  using EventSimulation\n\nfunction arrival(s)\n    t = s.now\n    println( Arrived at  , s.now)\n    register!(s, x -  println( Left at $(x.now) that arrived at $t ), 1.5)\nend\n\ns = Scheduler()\nrepeat_register!(s, arrival, x -  1.0)\n\ngo!(s, 7)  In this example we show how  arrival  function can be scheduled to be repeatedly put into event queue in time deltas defined by anonymous function  x -  1.0 .  Aslo observe that we have passed second argument  7  to function  go!  which will force unconditional termination of the simulation after this moment.  Exercise :  Think what would happen if the termination time would be omitted in the expression  go!(s, 7) . How you could use function  terminate!  inside definition of  arrival  to get a similar effect. What would be the difference?", 
            "title": "Defining infinite source of events"
        }, 
        {
            "location": "/tutorial/#defining-custom-simulation-state", 
            "text": "Now let us add a simple counter of number of customers in the system:  using EventSimulation\n\nmutable struct CounterState  : AbstractState\n    count::Int\nend\n\nfunction arrival(s)\n    function departure(x)\n        x.state.count -= 1\n        println( Left at $(x.now) that arrived at $t and left  ,\n                x.state.count,   other customers )\n    end\n\n    t = s.now\n    println( Arrived at  , s.now,   and met  , s.state.count,   other customers )\n    register!(s, departure, 1.0)\n    s.state.count += 1\nend\n\ns = Scheduler(CounterState(0))\n\nsrand(1)\nrepeat_register!(s, arrival, x -  rand())\ngo!(s, 10)  Observe that all functions in EventSimulation receive  Scheduler  as an argument and therefore they have acces to current simulation time and simulation state.  Additionally we have changed customer arrival behavior to random.  Exercise :  Try changing customer's arrival rate to the exponential distribution using  randexp  function. Next change time in system distribution to the Gamma distribution. You can find it in  Distributions  package.", 
            "title": "Defining custom simulation state"
        }, 
        {
            "location": "/tutorial/#monitoring-simulation", 
            "text": "Let us calculate how many customers are present in the above system using custom  monitor .  using EventSimulation\n\nmutable struct CounterState  : AbstractState\n    count::Int\n    total_time::Float64\n    customer_time::Float64\nend\n\nfunction arrival(s)\n    register!(s, departure, 1.0)\n    s.state.count += 1\nend\n\nfunction departure(s)\n    s.state.count -= 1\nend\n\nfunction monitor(s, \u0394)\n    s.state.total_time += \u0394\n    s.state.customer_time += \u0394 * s.state.count\nend\n\ncs = CounterState(0, 0.0, 0.0)\ns = Scheduler(cs, Float64, monitor)\n\nsrand(1)\nrepeat_register!(s, arrival, x -  rand())\ngo!(s, 100_000)\nprintln( Average number of customers in a system is  ,\n        cs.customer_time/cs.total_time)  Observe that  monitor  usually will modify simulation state to gather the simulation statistics. Other approaches could use global variables or variables defined in closure of  monitor , but using simulation state is the recommended approach.  Exercise :  Think if the obtained result is in line with  Little's law . Try changing arrival rate and time in the system to check it. As a more advanced exercise make  monitor  collect data only when simulation time is greater or equal than 100 (i.e. discarding simulation burn-in period).", 
            "title": "Monitoring simulation"
        }, 
        {
            "location": "/tutorial/#introduction-to-resources", 
            "text": "Now we will consider two streams of agents. Supplier provides one unit of good every one unit of time. There are customers that arrive randomly and want to buy a random amount of good. Maximally two customers .  using EventSimulation\n\nmutable struct GoodState  : AbstractState\n    good::SimResource{Float64}\nend\n\nfunction delivery(s)\n    provide!(s, s.state.good, 1.0)\n    print_with_color(:green,  Delivered 1.0 at  , s.now,  \\n )\nend\n\nfunction customer(s)\n    function leave(x)\n        println( Left at  , x.now,   with quantity  , round(demand, 4))\n    end\n    demand = rand()\n    print( Arrived at  , round(s.now, 4),   with demand  , round(demand, 4))\n    if !request!(s, s.state.good, demand, leave)[1]\n        print_with_color(:red,   but line was too long and left with nothing\\n )\n    else\n        println(  and went into a queue )\n    end\nend\n\nfunction balance(s)\n    info( Amount of good in storage:  ,\n         round(s.state.good.quantity, 4),   at time  , s.now)\nend\n\ns = Scheduler(GoodState(SimResource{Float64}(max_requests=2)))\n\nsrand(1)\nrepeat_register!(s, delivery, x -  1.0)\nrepeat_register!(s, customer, x -  rand())\nrepeat_register!(s, balance, x -  x.now == 0 ? 1.000001 : 1.0)\ngo!(s, 5)  Observe that fulfillment of pending requests by  SimResource  is immediate. This means that the amount is passed to a request from the container before the request event executed.  Exercise :  We have used a fixed value of  0.000001  as an increment over an integer number to invoke  balance . Rewrite the example using  PriorityTime  type in such a way that  balance  is invoked at integer times but with priority low enough.  This is the end of this introductory tutorial. More advanced features are covered in examples contained in  /examples/  directory.", 
            "title": "Introduction to resources"
        }, 
        {
            "location": "/reference/", 
            "text": "EventSimulation Reference\n\n\n#\n\n\nEventSimulation\n \n \nModule\n.\n\n\nEventSimulation is an event-based discrete event simulation engine.\n\n\nsource\n\n\n#\n\n\nEventSimulation.Action\n \n \nType\n.\n\n\nStructure holding an information that \nwhat\n should be executed by scheduler at time \nwhen\n; \nwhat\n should accept one argument of type \nScheduler\n.\n\n\nsource\n\n\n#\n\n\nEventSimulation.AbstractState\n \n \nType\n.\n\n\nAbstract type for holding state of the simulation\n\n\nsource\n\n\n#\n\n\nEventSimulation.EmptyState\n \n \nType\n.\n\n\nSimplest concrete type implementing \nAbstractState\n that does not hold any data\n\n\nsource\n\n\n#\n\n\nEventSimulation.Scheduler\n \n \nType\n.\n\n\nHolds information about current simulation state Contains the following fields:\n\n\n\n\nnow\n         current simulation time\n\n\nevent_queue\n priority queue of \nActions\n planned to be executed\n\n\nstate\n       user defined subtype of \nAbstractState\n of the simulation\n\n\nmonitor\n     function that is called before event is triggered               must accept two arguments \nScheduler\n and \n\u0394\n, a difference               between time of event to be executed and time of last executed event\n\n\n\n\nIf two \nAction\ns have identical \nwhen\n time in \nevent_queue\n then the order of their execution is undefined\n\n\nWhen \nmonitor\n is executed the event to happen is still on \nevent_queue\n, but time is updated to time when the event is to be executed (i.e. \nmonitor\n sees the state of the simulation just before the event is triggered). Therefore for calculating summary statistics \nmonitor\n may assume that the simulation spent \n\u0394\n time in this state. Function \nmonitor\n should not modify \nevent_queue[1]\n as EventSimulation assumes that the event to be triggered after \nmonitor\n executes will not be modified. Additionally it it not guaranteed that \nevent_queue[1]\n will be executed after \nmonitor\n finishes because simulation might terminate earlier.\n\n\nsource\n\n\n#\n\n\nEventSimulation.register!\n \n \nFunction\n.\n\n\nregister!(s, what, \u0394)\n\n\n\n\nPut \nwhat\n at time \ns.now+\u0394\n to \ns.event_queue\n. \nwhat\n must accept exactly one argument of type \nScheduler\n. Returns inserted \nAction\n.\n\n\nsource\n\n\n#\n\n\nEventSimulation.repeat_register!\n \n \nFunction\n.\n\n\nrepeat_register!(s, what, interval)\n\n\n\n\nPut \nwhat\n to \ns.event_queue\n repeatedly in time intervals specified by \ninterval\n function, which must accept one argument of type \nScheduler\n. \nwhat\n must accept exactly one argument of type \nScheduler\n. Returns first inserted \nAction\n. Calling \nterminate!\n in function \ninterval\n will not stop the simulation.\n\n\nsource\n\n\n#\n\n\nEventSimulation.bulk_register!\n \n \nFunction\n.\n\n\nbulk_register!(s, who, what, \u0394, randomize)\n\n\n\n\nPut event at time \ns.now+\u0394\n to \ns.event_queue\n that will execute \nwhat(scheduler, w)\n for all \nw\n in \nwho\n. If \nrandomize\n is \nfalse\n then \nwho\n is traversed in natural order otherwise it is traversed in random order. \nwhat\n must accept exactly two arguments of type \nScheduler\n and \ntypeof(who)\n. Returns inserted bulk \nAction\n.\n\n\nFunction is designed to efficiently handle case when the same action has to be executed at the same simulation time by many agents.\n\n\nsource\n\n\n#\n\n\nEventSimulation.repeat_bulk_register!\n \n \nFunction\n.\n\n\nrepeat_bulk_register!(s, who, what, \u0394, randomize)\n\n\n\n\nRepeat \nbulk_register!\n at time intervals specified by \ninterval\n function, which must accept \nScheduler\n argument. \nwhat\n must accept exactly two arguments of type \nScheduler\n and \ntypeof(who)\n. Returns first inserted bulk \nAction\n. Calling \nterminate!\n in function \ninterval\n will not stop the simulation.\n\n\nsource\n\n\n#\n\n\nEventSimulation.interrupt!\n \n \nFunction\n.\n\n\ninterrupt!(s, a)\n\n\n\n\nFirst occurence of action \na\n is replaced by no-op in event queue. This way there is no need to fix heap in this operation and it is fast. Returns \ntrue\n if \na\n was found in queue and \nfalse\n otherwise.\n\n\nsource\n\n\n#\n\n\nEventSimulation.terminate!\n \n \nFunction\n.\n\n\nterminate!(s)\n\n\n\n\nEmpties \ns.event_queue\n which will lead to termination of simulation unless it is refilled before execution returns to \ngo!\n. Useful for event-triggered termination of simulation.\n\n\nsource\n\n\n#\n\n\nEventSimulation.go!\n \n \nFunction\n.\n\n\ngo!(s, until)\n\n\n\n\nRuns simulation defined by \ns\n until \ns.now\n is greater or equal than \nuntil\n or \ns.event_queue\n is empty (i.e. nothing is left to be done). By default \nuntil\n equals \nInf\n.\n\n\nsource\n\n\n#\n\n\nEventSimulation.AbstractReservoir\n \n \nType\n.\n\n\nAbstract class for reservoirs. \nSimQueue\n and \nSimResource\n are concrete types implementing it.\n\n\nsource\n\n\n#\n\n\nEventSimulation.SimResource\n \n \nType\n.\n\n\nResource type for holding numeric values (like amount of liquid). It stores current \nquantity\n of matter and its allowed \nlo\n and \nhi\n amounts. Servers can get matter from the resource with optional maximum number of requests pending for fulfillment.\n\n\nFields:\n\n\n\n\nquantity\n       current quantity in resource\n\n\nlo\n            minimum quantity of resource\n\n\nhi\n            maximum quantity of resource\n\n\nfifo_requests\n if \ntrue\n \nrequests\n is FIFO, otherwise LIFO\n\n\nmax_requests\n  maximum \nrequests\n size\n\n\nrequests\n      vector of request and requested quantity\n\n\n\n\nFunctions in \nrequests\n must accept one argument \nScheduler\n, so they should know the amount they requested. When resource arrives to a queue there is a try to immediately dispatch it to pending requests. When new request arrives there is a try to immediately fulfill it.\n\n\nInitially an empty \nSimResource\n with no requests is constructed. Initial \nquantity\n, \nlo\n and \nhi\n may be provided. By default \nSimResource\n is empty, and has minimum quantity of zero and unbounded maximum.\n\n\nsource\n\n\n#\n\n\nEventSimulation.ResourceRequest\n \n \nType\n.\n\n\nInternal structure that remembers that \nquantity\n was requested by \nrequest\n.\n\n\nsource\n\n\n#\n\n\nEventSimulation.SimQueue\n \n \nType\n.\n\n\nSimQueue type for holding arbitrary objects \nO\n. It allows objects to be waiting in a queue with optional maximum queue size. Servers can get objects from the queue with optional maximum number of requests pending for fulfillment.\n\n\nFields:\n\n\n\n\nfifo_queue\n    if \ntrue\n \nqueue\n is FIFO, otherwise LIFO\n\n\nmax_queue\n     maximum \nqueue\n size\n\n\nqueue\n         vector of objects in a queue\n\n\nfifo_requests\n if \ntrue\n \nrequests\n is FIFO, otherwise LIFO\n\n\nmax_requests\n  maximum \nrequests\n size\n\n\nrequests\n      vector of request functions\n\n\n\n\nFunctions in \nrequests\n must accept two arguments \nScheduler\n and \nO\n. When \nO\n arrives to a queue there is a try to immediately feed it to pending requests. When new request arrives there is a try to immediately provide it with \nO\n.\n\n\nInitially an empty \nSimQueue\n with no requests is constructed. By default \nqueue\n and \nrequests\n have FIFO policy and are unbounded.\n\n\nsource\n\n\n#\n\n\nEventSimulation.request!\n \n \nFunction\n.\n\n\nrequest!(s, r, quantity, request)\nrequest!(s, q, request)\n\n\n\n\nFunction used to register request for resource in \nSimResource\n or object from \nSimQueue\n.\n\n\nIn \nSimResource\n requested \nquantity\n must be provided and \nrequest\n accepts only \nScheduler\n argument (it must know what it wanted). Returns tuple of:\n\n\n\n\ntrue\n if successfull and \nfalse\n when too many requests were made\n\n\nResourceRequest\n object created\n\n\n\n\nIn \nSimResource\n function \nrequest\n must accept one argument \nScheduler\n. In \nSimQueue\n function \nrequest\n must accept two arguments \nScheduler\n and object.\n\n\nsource\n\n\n#\n\n\nEventSimulation.waive!\n \n \nFunction\n.\n\n\nwaive!(r, res_request)\nwaive!(q, request)\n\n\n\n\nAllows to remove first occurence that would be served of \nres_request\n from \nSimResource\n or \nrequest\n from \nSimQueue\n.\n\n\nReturns \ntrue\n on success and \nfalse\n if \nres_request\n or \nrequest\n respectively was not found.\n\n\nsource\n\n\n#\n\n\nEventSimulation.provide!\n \n \nFunction\n.\n\n\nprovide!(s, r, quantity)\nprovide!(s, q, object)\n\n\n\n\nAllows to fill \nSimResource\n with \nquantity\n or \nSimQueue\n with \nobject\n.\n\n\nIn \nSimResource\n changes the balance of \nr.quantity\n. Given quantity may be any number, but the balance of \nSimResource\n will be changed only in \nlo\n-\nhi\n range. Returns the actual change in \nSimResource\n balance.\n\n\nIn \nSimQueue\n adds \nobject\n to \nq.queue\n. Returns \ntrue\n on success and \nfalse\n if there were too many objects in queue already.\n\n\nsource\n\n\n#\n\n\nEventSimulation.withdraw!\n \n \nFunction\n.\n\n\nwithdraw!(q, object)\n\n\n\n\nAllows to remove first occurrence that would be served of \nobject\n from \nSimQueue\n.\n\n\nReturns \ntrue\n on success and \nfalse\n if \nobject\n was not found.\n\n\nsource\n\n\n#\n\n\nEventSimulation.PriorityTime\n \n \nType\n.\n\n\nSubtype of \nReal\n defining a lexicographically comparable pair of \nReal\n. It is designed to be used by \nScheduler\n where standard real numbers run to a problem of undefined order of undefined order of removal from priority queue.\n\n\nPriorityTime\n two fields \ntime\n and \npriority\n may have different types, but both have to be subtypes of \nReal\n. \npriority\n should be used to determine order of execution of \nAction\ns that have the same time. Two actions with identical \ntime\n and \npriority\n have undefined oreder of execution so this should be avoided.\n\n\nPriorityTime\n type has defined lexicographic order and \n+\n, \n-\n. It is immutable, has a custom \nhash\n function and conversions from \nReal\n types.\n\n\nsource", 
            "title": "Reference"
        }, 
        {
            "location": "/reference/#eventsimulation-reference", 
            "text": "#  EventSimulation     Module .  EventSimulation is an event-based discrete event simulation engine.  source  #  EventSimulation.Action     Type .  Structure holding an information that  what  should be executed by scheduler at time  when ;  what  should accept one argument of type  Scheduler .  source  #  EventSimulation.AbstractState     Type .  Abstract type for holding state of the simulation  source  #  EventSimulation.EmptyState     Type .  Simplest concrete type implementing  AbstractState  that does not hold any data  source  #  EventSimulation.Scheduler     Type .  Holds information about current simulation state Contains the following fields:   now          current simulation time  event_queue  priority queue of  Actions  planned to be executed  state        user defined subtype of  AbstractState  of the simulation  monitor      function that is called before event is triggered               must accept two arguments  Scheduler  and  \u0394 , a difference               between time of event to be executed and time of last executed event   If two  Action s have identical  when  time in  event_queue  then the order of their execution is undefined  When  monitor  is executed the event to happen is still on  event_queue , but time is updated to time when the event is to be executed (i.e.  monitor  sees the state of the simulation just before the event is triggered). Therefore for calculating summary statistics  monitor  may assume that the simulation spent  \u0394  time in this state. Function  monitor  should not modify  event_queue[1]  as EventSimulation assumes that the event to be triggered after  monitor  executes will not be modified. Additionally it it not guaranteed that  event_queue[1]  will be executed after  monitor  finishes because simulation might terminate earlier.  source  #  EventSimulation.register!     Function .  register!(s, what, \u0394)  Put  what  at time  s.now+\u0394  to  s.event_queue .  what  must accept exactly one argument of type  Scheduler . Returns inserted  Action .  source  #  EventSimulation.repeat_register!     Function .  repeat_register!(s, what, interval)  Put  what  to  s.event_queue  repeatedly in time intervals specified by  interval  function, which must accept one argument of type  Scheduler .  what  must accept exactly one argument of type  Scheduler . Returns first inserted  Action . Calling  terminate!  in function  interval  will not stop the simulation.  source  #  EventSimulation.bulk_register!     Function .  bulk_register!(s, who, what, \u0394, randomize)  Put event at time  s.now+\u0394  to  s.event_queue  that will execute  what(scheduler, w)  for all  w  in  who . If  randomize  is  false  then  who  is traversed in natural order otherwise it is traversed in random order.  what  must accept exactly two arguments of type  Scheduler  and  typeof(who) . Returns inserted bulk  Action .  Function is designed to efficiently handle case when the same action has to be executed at the same simulation time by many agents.  source  #  EventSimulation.repeat_bulk_register!     Function .  repeat_bulk_register!(s, who, what, \u0394, randomize)  Repeat  bulk_register!  at time intervals specified by  interval  function, which must accept  Scheduler  argument.  what  must accept exactly two arguments of type  Scheduler  and  typeof(who) . Returns first inserted bulk  Action . Calling  terminate!  in function  interval  will not stop the simulation.  source  #  EventSimulation.interrupt!     Function .  interrupt!(s, a)  First occurence of action  a  is replaced by no-op in event queue. This way there is no need to fix heap in this operation and it is fast. Returns  true  if  a  was found in queue and  false  otherwise.  source  #  EventSimulation.terminate!     Function .  terminate!(s)  Empties  s.event_queue  which will lead to termination of simulation unless it is refilled before execution returns to  go! . Useful for event-triggered termination of simulation.  source  #  EventSimulation.go!     Function .  go!(s, until)  Runs simulation defined by  s  until  s.now  is greater or equal than  until  or  s.event_queue  is empty (i.e. nothing is left to be done). By default  until  equals  Inf .  source  #  EventSimulation.AbstractReservoir     Type .  Abstract class for reservoirs.  SimQueue  and  SimResource  are concrete types implementing it.  source  #  EventSimulation.SimResource     Type .  Resource type for holding numeric values (like amount of liquid). It stores current  quantity  of matter and its allowed  lo  and  hi  amounts. Servers can get matter from the resource with optional maximum number of requests pending for fulfillment.  Fields:   quantity        current quantity in resource  lo             minimum quantity of resource  hi             maximum quantity of resource  fifo_requests  if  true   requests  is FIFO, otherwise LIFO  max_requests   maximum  requests  size  requests       vector of request and requested quantity   Functions in  requests  must accept one argument  Scheduler , so they should know the amount they requested. When resource arrives to a queue there is a try to immediately dispatch it to pending requests. When new request arrives there is a try to immediately fulfill it.  Initially an empty  SimResource  with no requests is constructed. Initial  quantity ,  lo  and  hi  may be provided. By default  SimResource  is empty, and has minimum quantity of zero and unbounded maximum.  source  #  EventSimulation.ResourceRequest     Type .  Internal structure that remembers that  quantity  was requested by  request .  source  #  EventSimulation.SimQueue     Type .  SimQueue type for holding arbitrary objects  O . It allows objects to be waiting in a queue with optional maximum queue size. Servers can get objects from the queue with optional maximum number of requests pending for fulfillment.  Fields:   fifo_queue     if  true   queue  is FIFO, otherwise LIFO  max_queue      maximum  queue  size  queue          vector of objects in a queue  fifo_requests  if  true   requests  is FIFO, otherwise LIFO  max_requests   maximum  requests  size  requests       vector of request functions   Functions in  requests  must accept two arguments  Scheduler  and  O . When  O  arrives to a queue there is a try to immediately feed it to pending requests. When new request arrives there is a try to immediately provide it with  O .  Initially an empty  SimQueue  with no requests is constructed. By default  queue  and  requests  have FIFO policy and are unbounded.  source  #  EventSimulation.request!     Function .  request!(s, r, quantity, request)\nrequest!(s, q, request)  Function used to register request for resource in  SimResource  or object from  SimQueue .  In  SimResource  requested  quantity  must be provided and  request  accepts only  Scheduler  argument (it must know what it wanted). Returns tuple of:   true  if successfull and  false  when too many requests were made  ResourceRequest  object created   In  SimResource  function  request  must accept one argument  Scheduler . In  SimQueue  function  request  must accept two arguments  Scheduler  and object.  source  #  EventSimulation.waive!     Function .  waive!(r, res_request)\nwaive!(q, request)  Allows to remove first occurence that would be served of  res_request  from  SimResource  or  request  from  SimQueue .  Returns  true  on success and  false  if  res_request  or  request  respectively was not found.  source  #  EventSimulation.provide!     Function .  provide!(s, r, quantity)\nprovide!(s, q, object)  Allows to fill  SimResource  with  quantity  or  SimQueue  with  object .  In  SimResource  changes the balance of  r.quantity . Given quantity may be any number, but the balance of  SimResource  will be changed only in  lo - hi  range. Returns the actual change in  SimResource  balance.  In  SimQueue  adds  object  to  q.queue . Returns  true  on success and  false  if there were too many objects in queue already.  source  #  EventSimulation.withdraw!     Function .  withdraw!(q, object)  Allows to remove first occurrence that would be served of  object  from  SimQueue .  Returns  true  on success and  false  if  object  was not found.  source  #  EventSimulation.PriorityTime     Type .  Subtype of  Real  defining a lexicographically comparable pair of  Real . It is designed to be used by  Scheduler  where standard real numbers run to a problem of undefined order of undefined order of removal from priority queue.  PriorityTime  two fields  time  and  priority  may have different types, but both have to be subtypes of  Real .  priority  should be used to determine order of execution of  Action s that have the same time. Two actions with identical  time  and  priority  have undefined oreder of execution so this should be avoided.  PriorityTime  type has defined lexicographic order and  + ,  - . It is immutable, has a custom  hash  function and conversions from  Real  types.  source", 
            "title": "EventSimulation Reference"
        }
    ]
}