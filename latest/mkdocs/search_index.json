{
    "docs": [
        {
            "location": "/", 
            "text": "EventSimulation.jl\n\n\nAn event based Discrete Event Simulation engine for Julia.\n\n\n\n\nPackage features\n\n\n\n\nregister/interrupt execution of events\n\n\nresource (continuous homogenous good) reservoir\n\n\nqueue (arbitrary objects) reservoir\n\n\n\n\n\n\nExamples\n\n\nExamples contained in \n/examples/\n directory:\n\n\n\n\nmms_example.jl\n: comparison of several implementations of M/M/s queue\n\n\nmm1_example.jl\n: basic implementation of M/M/1 queue with use of monitor\n\n\nbank_renege_1.jl\n: bank renege model (reimplementation of SimPy example)\n\n\nbank_renege_2.jl\n: bank renege model (reimplementation of SimPy example)\n\n\nmovie_renege.jl\n: movie renege model (reimplementation of SimPy example)\n\n\nfaxqueue.jl\n: a two-stage fax queue model; adaptation of Nelson (2013): \nFoundations and Methods of Stochastic Simulation\n, chap. 4.6, example\n\n\n\n\nThe models that are reimplemnetation of SimPy run an order of magnitude (\n20x) faster than in \nSimPy\n or \nSimJulia\n process oriented DES engines.\n\n\n\n\nTypes and functions defined in EventSimulation package\n\n\n#\n\n\nEventSimulation\n \n \nModule\n.\n\n\nEventSimulation is an event-based discrete event simulation engine.\n\n\nsource\n\n\n#\n\n\nEventSimulation.Action\n \n \nType\n.\n\n\nStructure holding an information that \nwhat\n should be executed by scheduler at time \nwhen\n \nwhat\n should accept one argument of type \nScheduler\n.\n\n\nsource\n\n\n#\n\n\nEventSimulation.AbstractState\n \n \nType\n.\n\n\nAbstract type for holding state of the simulation\n\n\nsource\n\n\n#\n\n\nEventSimulation.EmptyState\n \n \nType\n.\n\n\nSimplest concrete type implementing \nAbstractState\n that does not hold any data\n\n\nsource\n\n\n#\n\n\nEventSimulation.Scheduler\n \n \nType\n.\n\n\nHolds information about current simulation state Contains three fields:\n\n\n\n\nnow\n         current simulation time\n\n\nevent_queue\n priority queue of \nActions\n planned to be executed\n\n\nstate\n       user defined subtype of \nAbstractState\n of the simulation\n\n\nmonitor\n     function that is called before event is triggered               must accept two arguments \nScheduler\n and \n\u0394\n that is time               of upcoming event and value of \nnow\n before this event\n\n\n\n\nIf two \nAction\ns have identical \nwhen\n time in \nevent_queue\n then the order of their execution is undefined\n\n\nWhen \nmonitor\n is executed the event to happen is still on \nevent_queue\n, but time is updated to time when the event is to be executed (i.e. \nmonitor\n sees the state of the simulation just before the event is triggered).\n\n\nsource\n\n\n#\n\n\nEventSimulation.register!\n \n \nFunction\n.\n\n\nregister!(s, what, \u0394)\n\n\n\n\nPut \nwhat\n at time \ns.now+\u0394\n to \ns.event_queue\n. \nwhat\n must accept exactly one argument of type \nScheduler\n. Returns inserted \nAction\n.\n\n\nsource\n\n\n#\n\n\nEventSimulation.repeat_register!\n \n \nFunction\n.\n\n\nrepeat_register!(s, what, interval)\n\n\n\n\nPut \nwhat\n to \ns.event_queue\n repeatedly in time intervals specified by \ninterval\n function, which must accept one argument of type \nScheduler\n. \nwhat\n must accept exactly one argument of type \nScheduler\n. Returns first inserted \nAction\n.\n\n\nsource\n\n\n#\n\n\nEventSimulation.bulk_register!\n \n \nFunction\n.\n\n\nbulk_register!(s, who, what, \u0394, randomize)\n\n\n\n\nPut event at time \ns.now+\u0394\n to \ns.event_queue\n that will execute \nwhat(scheduler, w)\n for all \nw\n in \nwho\n. If \nrandomize\n is \nfalse\n then \nwho\n is traversed in natural order otherwise it is traversed in random order. \nwhat\n must accept exactly tow arguments of type \nScheduler\n and \ntypeof(who)\n. Returns inserted bulk \nAction\n.\n\n\nFunction is designed to efficiently handle case when the same action has to be executed at the same simulation time by many agents.\n\n\nsource\n\n\n#\n\n\nEventSimulation.repeat_bulk_register!\n \n \nFunction\n.\n\n\nrepeat_bulk_register!(s, who, what, \u0394, randomize)\n\n\n\n\nRepeat \nbulk_register!\n at time intervals specified by \ninterval\n, which must accept \nScheduler\n argument. \nwhat\n must accept exactly tow arguments of type \nScheduler\n and \ntypeof(who)\n. Returns first inserted bulk \nAction\n.\n\n\nsource\n\n\n#\n\n\nEventSimulation.interrupt!\n \n \nFunction\n.\n\n\ninterrupt!(s, a)\n\n\n\n\nFirst occurence of action \na\n is replaced by no-op in event queue. This way there is no need to fix heap in this operation and it is fast. Returns \ntrue\n if \na\n was found in queue and \nfalse\n otherwise.\n\n\nsource\n\n\n#\n\n\nEventSimulation.terminate!\n \n \nFunction\n.\n\n\nterminate!(s)\n\n\n\n\nEmpties \ns.event_queue\n which will lead to termination of simulation unless it is refilled before execution returns to \ngo!\n. Useful for event-triggered termination of simulation\n\n\nsource\n\n\n#\n\n\nEventSimulation.go!\n \n \nFunction\n.\n\n\ngo!(s, until)\n\n\n\n\nRuns simulation defined by \ns\n until \ns.now\n is greater or equal than \nuntil\n or \ns.event_queue\n is empty (i.e. nothing is left to be done).\n\n\nsource\n\n\n#\n\n\nEventSimulation.AbstractReservoir\n \n \nType\n.\n\n\nAbstract class for reservoirs. \nQueue\n and \nResource\n are concrete types implementing it.\n\n\nsource\n\n\n#\n\n\nEventSimulation.ResourceRequest\n \n \nType\n.\n\n\nInternal structure that remembers that \nquantity\n was requested by \nrequest\n.\n\n\nsource\n\n\n#\n\n\nEventSimulation.Resource\n \n \nType\n.\n\n\nResource type for holding numeric values (like amount of liquid). It stores current \nquantity\n of matter and its allowed \nlo\n and \nhi\n amounts. Servers can get objects from the queue with optional maximum number of requests pending for fulfillment.\n\n\nFields:\n\n\n\n\nquantiy\n    current quantity in resource\n\n\nlo\n            minimum quantity of resource\n\n\nhi\n            maximum quantity of resource\n\n\nfifo_requests\n if \ntrue\n \nrequests\n is fifo, otherwise lifo\n\n\nmax_requests\n  maximum \nrequests\n size\n\n\nrequests\n      vector of request and requested quantity\n\n\n\n\nFunctions in \nrequests\n must accept one argument \nScheduler\n, so they should know the amount they requested. When resource arrives to a queue there is a try to immediately dispatch it to pending requests. When new request arrives there is a try to immediately fulfill it.\n\n\nInitially an empty \nResource\n with no requests is constructed. Initial \nquantity\n, \nlo\n and \nhi\n may be provided. By default \nResource\n is empty, and has minimum quantity of zero and unbounded maximum.\n\n\nsource\n\n\n#\n\n\nEventSimulation.Queue\n \n \nType\n.\n\n\nQueue type for holding arbitrary objects \nO\n. It allows objects to be waiting in a queue with optional maximum queue size. Servers can get objects from the queue with optional maximum number of requests pending for fulfillment.\n\n\nFields:\n\n\n\n\nfifo_queue\n    if \ntrue\n \nqueue\n is fifo, otherwise lifo\n\n\nmax_queue\n     maximum \nqueue\n size\n\n\nqueue\n         vector of objects in a queue\n\n\nfifo_requests\n if \ntrue\n \nrequests\n is fifo, otherwise lifo\n\n\nmax_requests\n  maximum \nrequests\n size\n\n\nrequests\n      vector of request functions\n\n\n\n\nFunctions in \nrequests\n must accept two arguments \nScheduler\n and \nO\n. When \nO\n arrives to a queue there is a try to immediately dispatch it to pending requests. When new request arrives there is a try to immediately provide it with \nO\n.\n\n\nInitially an empty \nQueue\n with no requests is constructed. By default \nqueue\n and \nrequests\n have fifo policy and are unbounded.\n\n\nsource\n\n\n#\n\n\nEventSimulation.request!\n \n \nFunction\n.\n\n\nrequest!(s, r, quantity, request)\nrequest!(s, q, request)\n\n\n\n\nFunction used to register request for resource in \nResourse\n or object from `Queue.\n\n\nIn \nResource\n requested \nquantity\n must be provided and \nrequest\n accepts only \nScheduler\n argument (it must know what it wanted). Returns tuple of:\n\n\n\n\ntrue\n if successfull and \nfalse\n when too many requests were made\n\n\nResourceRequest\n object created\n\n\n\n\nIn \nQueue\n function \nrequest\n must accept two arguments \nScheduler\n and object. Returns \ntrue\n if successfull and \nfalse\n when too many requests were made.\n\n\nsource\n\n\n#\n\n\nEventSimulation.waive!\n \n \nFunction\n.\n\n\nwaive!(r, res_request)\nwaive!(q, request)\n\n\n\n\nAllows to remove first occurence that would be served of \nres_request\n from \nResource\n or \nrequest\n from \nQueue\n.\n\n\nReturns \ntrue\n on success and \nfalse\n if \nres_request\n or \nrequest\n respectively was not found.\n\n\nsource\n\n\n#\n\n\nEventSimulation.provide!\n \n \nFunction\n.\n\n\nprovide!(s, r, quantity)\nprovide!(s, q, object)\n\n\n\n\nAllows to fill \nResource\n with \nquantity\n or \nQueue\n with \nobject\n.\n\n\nIn \nResource\n changes the balance of \nr.quantity\n. Given quantity may be any number, but the balance of \nResource\n will be changed only in \nlo\n-\nhi\n range. Returns the actual change in \nResource\n balance.\n\n\nIn \nQueue\n adds \nobject\n to \nq.queue\n. Returns \ntrue\n on success and \nfalse\n if there were too many objects in queue already.\n\n\nsource\n\n\n#\n\n\nEventSimulation.withdraw!\n \n \nFunction\n.\n\n\nwithdraw!(q, object)\n\n\n\n\nAllows to remove first occurence that would be served of \nobject\n from \nQueue\n.\n\n\nReturns \ntrue\n on success and \nfalse\n if \nobject\n was not found.\n\n\nsource\n\n\n#\n\n\nEventSimulation.PriorityTime\n \n \nType\n.\n\n\nSubtype of \nReal\n defining a lexicographically comparable pair of \nReal\n. It is designed to be used by \nScheduler\n where standard real numbers run to a problem of undefined order of undefined order of removal from priority queue.\n\n\nPriorityTime\n two fields \ntime\n and \npriority\n which may have different types, but both have to be subtypes of \nReal\n. \npriority\n should be used to determine order of execution of \nAction\ns that have the same time. Two actions with identical \ntime\n and \npriority\n have undefined oreder of execution so this should be avoided.\n\n\nPriorityTime\n type has defined lexicographic order and \n+\n, \n-\n. It is immutable, has a custom \nhash\n function and conversions from \nReal\n types.\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#eventsimulationjl", 
            "text": "An event based Discrete Event Simulation engine for Julia.", 
            "title": "EventSimulation.jl"
        }, 
        {
            "location": "/#package-features", 
            "text": "register/interrupt execution of events  resource (continuous homogenous good) reservoir  queue (arbitrary objects) reservoir", 
            "title": "Package features"
        }, 
        {
            "location": "/#examples", 
            "text": "Examples contained in  /examples/  directory:   mms_example.jl : comparison of several implementations of M/M/s queue  mm1_example.jl : basic implementation of M/M/1 queue with use of monitor  bank_renege_1.jl : bank renege model (reimplementation of SimPy example)  bank_renege_2.jl : bank renege model (reimplementation of SimPy example)  movie_renege.jl : movie renege model (reimplementation of SimPy example)  faxqueue.jl : a two-stage fax queue model; adaptation of Nelson (2013):  Foundations and Methods of Stochastic Simulation , chap. 4.6, example   The models that are reimplemnetation of SimPy run an order of magnitude ( 20x) faster than in  SimPy  or  SimJulia  process oriented DES engines.", 
            "title": "Examples"
        }, 
        {
            "location": "/#types-and-functions-defined-in-eventsimulation-package", 
            "text": "#  EventSimulation     Module .  EventSimulation is an event-based discrete event simulation engine.  source  #  EventSimulation.Action     Type .  Structure holding an information that  what  should be executed by scheduler at time  when   what  should accept one argument of type  Scheduler .  source  #  EventSimulation.AbstractState     Type .  Abstract type for holding state of the simulation  source  #  EventSimulation.EmptyState     Type .  Simplest concrete type implementing  AbstractState  that does not hold any data  source  #  EventSimulation.Scheduler     Type .  Holds information about current simulation state Contains three fields:   now          current simulation time  event_queue  priority queue of  Actions  planned to be executed  state        user defined subtype of  AbstractState  of the simulation  monitor      function that is called before event is triggered               must accept two arguments  Scheduler  and  \u0394  that is time               of upcoming event and value of  now  before this event   If two  Action s have identical  when  time in  event_queue  then the order of their execution is undefined  When  monitor  is executed the event to happen is still on  event_queue , but time is updated to time when the event is to be executed (i.e.  monitor  sees the state of the simulation just before the event is triggered).  source  #  EventSimulation.register!     Function .  register!(s, what, \u0394)  Put  what  at time  s.now+\u0394  to  s.event_queue .  what  must accept exactly one argument of type  Scheduler . Returns inserted  Action .  source  #  EventSimulation.repeat_register!     Function .  repeat_register!(s, what, interval)  Put  what  to  s.event_queue  repeatedly in time intervals specified by  interval  function, which must accept one argument of type  Scheduler .  what  must accept exactly one argument of type  Scheduler . Returns first inserted  Action .  source  #  EventSimulation.bulk_register!     Function .  bulk_register!(s, who, what, \u0394, randomize)  Put event at time  s.now+\u0394  to  s.event_queue  that will execute  what(scheduler, w)  for all  w  in  who . If  randomize  is  false  then  who  is traversed in natural order otherwise it is traversed in random order.  what  must accept exactly tow arguments of type  Scheduler  and  typeof(who) . Returns inserted bulk  Action .  Function is designed to efficiently handle case when the same action has to be executed at the same simulation time by many agents.  source  #  EventSimulation.repeat_bulk_register!     Function .  repeat_bulk_register!(s, who, what, \u0394, randomize)  Repeat  bulk_register!  at time intervals specified by  interval , which must accept  Scheduler  argument.  what  must accept exactly tow arguments of type  Scheduler  and  typeof(who) . Returns first inserted bulk  Action .  source  #  EventSimulation.interrupt!     Function .  interrupt!(s, a)  First occurence of action  a  is replaced by no-op in event queue. This way there is no need to fix heap in this operation and it is fast. Returns  true  if  a  was found in queue and  false  otherwise.  source  #  EventSimulation.terminate!     Function .  terminate!(s)  Empties  s.event_queue  which will lead to termination of simulation unless it is refilled before execution returns to  go! . Useful for event-triggered termination of simulation  source  #  EventSimulation.go!     Function .  go!(s, until)  Runs simulation defined by  s  until  s.now  is greater or equal than  until  or  s.event_queue  is empty (i.e. nothing is left to be done).  source  #  EventSimulation.AbstractReservoir     Type .  Abstract class for reservoirs.  Queue  and  Resource  are concrete types implementing it.  source  #  EventSimulation.ResourceRequest     Type .  Internal structure that remembers that  quantity  was requested by  request .  source  #  EventSimulation.Resource     Type .  Resource type for holding numeric values (like amount of liquid). It stores current  quantity  of matter and its allowed  lo  and  hi  amounts. Servers can get objects from the queue with optional maximum number of requests pending for fulfillment.  Fields:   quantiy     current quantity in resource  lo             minimum quantity of resource  hi             maximum quantity of resource  fifo_requests  if  true   requests  is fifo, otherwise lifo  max_requests   maximum  requests  size  requests       vector of request and requested quantity   Functions in  requests  must accept one argument  Scheduler , so they should know the amount they requested. When resource arrives to a queue there is a try to immediately dispatch it to pending requests. When new request arrives there is a try to immediately fulfill it.  Initially an empty  Resource  with no requests is constructed. Initial  quantity ,  lo  and  hi  may be provided. By default  Resource  is empty, and has minimum quantity of zero and unbounded maximum.  source  #  EventSimulation.Queue     Type .  Queue type for holding arbitrary objects  O . It allows objects to be waiting in a queue with optional maximum queue size. Servers can get objects from the queue with optional maximum number of requests pending for fulfillment.  Fields:   fifo_queue     if  true   queue  is fifo, otherwise lifo  max_queue      maximum  queue  size  queue          vector of objects in a queue  fifo_requests  if  true   requests  is fifo, otherwise lifo  max_requests   maximum  requests  size  requests       vector of request functions   Functions in  requests  must accept two arguments  Scheduler  and  O . When  O  arrives to a queue there is a try to immediately dispatch it to pending requests. When new request arrives there is a try to immediately provide it with  O .  Initially an empty  Queue  with no requests is constructed. By default  queue  and  requests  have fifo policy and are unbounded.  source  #  EventSimulation.request!     Function .  request!(s, r, quantity, request)\nrequest!(s, q, request)  Function used to register request for resource in  Resourse  or object from `Queue.  In  Resource  requested  quantity  must be provided and  request  accepts only  Scheduler  argument (it must know what it wanted). Returns tuple of:   true  if successfull and  false  when too many requests were made  ResourceRequest  object created   In  Queue  function  request  must accept two arguments  Scheduler  and object. Returns  true  if successfull and  false  when too many requests were made.  source  #  EventSimulation.waive!     Function .  waive!(r, res_request)\nwaive!(q, request)  Allows to remove first occurence that would be served of  res_request  from  Resource  or  request  from  Queue .  Returns  true  on success and  false  if  res_request  or  request  respectively was not found.  source  #  EventSimulation.provide!     Function .  provide!(s, r, quantity)\nprovide!(s, q, object)  Allows to fill  Resource  with  quantity  or  Queue  with  object .  In  Resource  changes the balance of  r.quantity . Given quantity may be any number, but the balance of  Resource  will be changed only in  lo - hi  range. Returns the actual change in  Resource  balance.  In  Queue  adds  object  to  q.queue . Returns  true  on success and  false  if there were too many objects in queue already.  source  #  EventSimulation.withdraw!     Function .  withdraw!(q, object)  Allows to remove first occurence that would be served of  object  from  Queue .  Returns  true  on success and  false  if  object  was not found.  source  #  EventSimulation.PriorityTime     Type .  Subtype of  Real  defining a lexicographically comparable pair of  Real . It is designed to be used by  Scheduler  where standard real numbers run to a problem of undefined order of undefined order of removal from priority queue.  PriorityTime  two fields  time  and  priority  which may have different types, but both have to be subtypes of  Real .  priority  should be used to determine order of execution of  Action s that have the same time. Two actions with identical  time  and  priority  have undefined oreder of execution so this should be avoided.  PriorityTime  type has defined lexicographic order and  + ,  - . It is immutable, has a custom  hash  function and conversions from  Real  types.  source", 
            "title": "Types and functions defined in EventSimulation package"
        }
    ]
}