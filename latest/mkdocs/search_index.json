{
    "docs": [
        {
            "location": "/", 
            "text": "EventSimulation.jl\n\n\nAn event based Discrete Event Simulation engine for Julia.\n\n\nIntended as a support library for teaching basic principles of Discrete Event Simulation.\n\n\n\n\nPackage features\n\n\n\n\nregister/interrupt execution of events\n\n\nresource (continuous homogenous good) reservoir\n\n\nqueue (arbitrary objects) reservoir\n\n\n\n\n\n\nExamples\n\n\nA quick start tutorial can be found \nhere\n.\n\n\nExamples contained in \n/examples/\n directory:\n\n\n\n\nmms_example.jl\n: comparison of several implementations of M/M/s queue\n\n\nmm1_example.jl\n: basic implementation of M/M/1 queue with use of monitor\n\n\nbank_renege_1.jl\n: bank renege model (reimplementation of SimPy example)\n\n\nbank_renege_2.jl\n: bank renege model (reimplementation of SimPy example)\n\n\nmovie_renege.jl\n: movie renege model (reimplementation of SimPy example)\n\n\nfaxqueue.jl\n: a two-stage fax queue model; adaptation of Nelson (2013): \nFoundations and Methods of Stochastic Simulation\n, chap. 4.6, example\n\n\n\n\nThe models that are reimplemnetation of SimPy run an order of magnitude (\n20x) faster than in \nSimPy\n or \nSimJulia\n process oriented DES engines.\n\n\n\n\nQuck overview of EventSimulation functionality\n\n\nGeneral functionality\n\n\n* `Action`: information that a given function should be executed at given\n  time\n* `AbstractState`: abstract type used for holding global simulation state\n* `EmptyState`: simplest empty concrete subtype of `AbstractState`\n* `Scheduler`\n* `register!`: puts `Action` into `Scheduler` queue\n* `repeat_register!`: puts `Action` into `Scheduler` queue repeatedly\n* `bulk_register!`: puts `Action` into `Scheduler` that will affect\n  multiple objects\n* `repeat_bulk_register!`: puts `Action` into `Scheduler` that will affect\n  multiple objects repeatedly\n* `interrupt!`: removes one given event from `Scheduler` queue\n* `terminate!`: removes all events from `Scheduler` queue\n* `go!`: executes the simulation\n\n\n\n\nContainers\n\n\n* `AbstractReservoir`: abstract type for defining reservoirs\n* `SimResource`: reservoir for divisible and homogeneous matter\n* `ResourceRequest`: information about request for a resource\n* `SimQueue`: reservoir for objects having unique identity\n* `request!`: registers demand for a resource/object\n* `waive!`: remove registered request from waiting list\n* `provide!`: add resource/object to reservoir\n  (or remove resource from `SimResource`)\n* `withdraw!`: remove object from `SimQueue`\n\n\n\n\nUtilities\n\n\n* `PriorityTime`: custom subtype of `Real` providing additional attribute\n  `priority` to normal time. Useful for giving execution priority of events\n  happening at the same time.\n\n\n\n\nFull documentation of types and functions defined in EventSimulation package can be found \nhere\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#eventsimulationjl", 
            "text": "An event based Discrete Event Simulation engine for Julia.  Intended as a support library for teaching basic principles of Discrete Event Simulation.", 
            "title": "EventSimulation.jl"
        }, 
        {
            "location": "/#package-features", 
            "text": "register/interrupt execution of events  resource (continuous homogenous good) reservoir  queue (arbitrary objects) reservoir", 
            "title": "Package features"
        }, 
        {
            "location": "/#examples", 
            "text": "A quick start tutorial can be found  here .  Examples contained in  /examples/  directory:   mms_example.jl : comparison of several implementations of M/M/s queue  mm1_example.jl : basic implementation of M/M/1 queue with use of monitor  bank_renege_1.jl : bank renege model (reimplementation of SimPy example)  bank_renege_2.jl : bank renege model (reimplementation of SimPy example)  movie_renege.jl : movie renege model (reimplementation of SimPy example)  faxqueue.jl : a two-stage fax queue model; adaptation of Nelson (2013):  Foundations and Methods of Stochastic Simulation , chap. 4.6, example   The models that are reimplemnetation of SimPy run an order of magnitude ( 20x) faster than in  SimPy  or  SimJulia  process oriented DES engines.", 
            "title": "Examples"
        }, 
        {
            "location": "/#quck-overview-of-eventsimulation-functionality", 
            "text": "General functionality  * `Action`: information that a given function should be executed at given\n  time\n* `AbstractState`: abstract type used for holding global simulation state\n* `EmptyState`: simplest empty concrete subtype of `AbstractState`\n* `Scheduler`\n* `register!`: puts `Action` into `Scheduler` queue\n* `repeat_register!`: puts `Action` into `Scheduler` queue repeatedly\n* `bulk_register!`: puts `Action` into `Scheduler` that will affect\n  multiple objects\n* `repeat_bulk_register!`: puts `Action` into `Scheduler` that will affect\n  multiple objects repeatedly\n* `interrupt!`: removes one given event from `Scheduler` queue\n* `terminate!`: removes all events from `Scheduler` queue\n* `go!`: executes the simulation  Containers  * `AbstractReservoir`: abstract type for defining reservoirs\n* `SimResource`: reservoir for divisible and homogeneous matter\n* `ResourceRequest`: information about request for a resource\n* `SimQueue`: reservoir for objects having unique identity\n* `request!`: registers demand for a resource/object\n* `waive!`: remove registered request from waiting list\n* `provide!`: add resource/object to reservoir\n  (or remove resource from `SimResource`)\n* `withdraw!`: remove object from `SimQueue`  Utilities  * `PriorityTime`: custom subtype of `Real` providing additional attribute\n  `priority` to normal time. Useful for giving execution priority of events\n  happening at the same time.  Full documentation of types and functions defined in EventSimulation package can be found  here .", 
            "title": "Quck overview of EventSimulation functionality"
        }, 
        {
            "location": "/tutorial/", 
            "text": "EventSimulation Tutorial\n\n\n\n\nInstallation\n\n\nIn REPL run \nPkg.add(\"EventSimulation\")\n to install the package and next \nusing EventSimulation\n to start using it.\n\n\n\n\nFirst simulation\n\n\nThis is a bare minimum simulation using EventSimulation:\n\n\nusing EventSimulation\n\nfunction arrived(s)\n    t = s.now\n    println(\nArrived at \n, s.now)\n    register!(s, x -\n println(\nLeft at $(x.now) that arrived at $t\n), 1.5)\nend\n\ns = Scheduler()\nfor t in 1.0:5.0\n    register!(s, arrived, t)\nend\n\ngo!(s)\n\n\n\n\nIn this example five customers arrive at times 1, 2, ..., 5 and stay in the system for 1.5 time units. Observe that in \narrived\n we use a closure to define anonymous function that is registered. In its body \nx.now\n will be taken from the state of the scheduler when the anonymous function is invoked but \nt\n is fixed in enclosing scope of \narrived\n function as the time of the arrival.\n\n\n!!! note \"Exercise\"\n    Test what happens if you replace \n$t\n with \n$(s.now)\n in the anonymous function. What is the reason of this behavior?\n\n\nWhen using EventSimulation working with closures is often the simplest way to develop a simulation so it is important that you understand this example.\n\n\n\n\nDefining infinite source of events\n\n\nusing EventSimulation\n\nfunction arrived(s)\n    t = s.now\n    println(\nArrived at \n, s.now)\n    register!(s, x -\n println(\nLeft at $(x.now) that arrived at $t\n), 1.5)\nend\n\ns = Scheduler()\nrepeat_register!(s, arrived, x -\n 1.0)\n\ngo!(s, 7)\n\n\n\n\n\nIn this example we show how \narrival\n function can be scheduled to be repeatedly put into event queue in time deltas defined by anonymous function \nx -\n 1.0\n.\n\n\nAslo observe that we have passed second argument \n7\n to function \ngo!\n which will force unconditional termination of the simulation after this moment.\n\n\n!!! note \"Exercise\"\n    Think what would happen if the termination time would be omitted in the expression \ngo!(s, 7)\n.\n\n\nHow you could use function `terminate!` inside definition of `arrived` to get a similar effect as . What would be the difference?", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#eventsimulation-tutorial", 
            "text": "", 
            "title": "EventSimulation Tutorial"
        }, 
        {
            "location": "/tutorial/#installation", 
            "text": "In REPL run  Pkg.add(\"EventSimulation\")  to install the package and next  using EventSimulation  to start using it.", 
            "title": "Installation"
        }, 
        {
            "location": "/tutorial/#first-simulation", 
            "text": "This is a bare minimum simulation using EventSimulation:  using EventSimulation\n\nfunction arrived(s)\n    t = s.now\n    println( Arrived at  , s.now)\n    register!(s, x -  println( Left at $(x.now) that arrived at $t ), 1.5)\nend\n\ns = Scheduler()\nfor t in 1.0:5.0\n    register!(s, arrived, t)\nend\n\ngo!(s)  In this example five customers arrive at times 1, 2, ..., 5 and stay in the system for 1.5 time units. Observe that in  arrived  we use a closure to define anonymous function that is registered. In its body  x.now  will be taken from the state of the scheduler when the anonymous function is invoked but  t  is fixed in enclosing scope of  arrived  function as the time of the arrival.  !!! note \"Exercise\"\n    Test what happens if you replace  $t  with  $(s.now)  in the anonymous function. What is the reason of this behavior?  When using EventSimulation working with closures is often the simplest way to develop a simulation so it is important that you understand this example.", 
            "title": "First simulation"
        }, 
        {
            "location": "/tutorial/#defining-infinite-source-of-events", 
            "text": "using EventSimulation\n\nfunction arrived(s)\n    t = s.now\n    println( Arrived at  , s.now)\n    register!(s, x -  println( Left at $(x.now) that arrived at $t ), 1.5)\nend\n\ns = Scheduler()\nrepeat_register!(s, arrived, x -  1.0)\n\ngo!(s, 7)  In this example we show how  arrival  function can be scheduled to be repeatedly put into event queue in time deltas defined by anonymous function  x -  1.0 .  Aslo observe that we have passed second argument  7  to function  go!  which will force unconditional termination of the simulation after this moment.  !!! note \"Exercise\"\n    Think what would happen if the termination time would be omitted in the expression  go!(s, 7) .  How you could use function `terminate!` inside definition of `arrived` to get a similar effect as . What would be the difference?", 
            "title": "Defining infinite source of events"
        }, 
        {
            "location": "/reference/", 
            "text": "EventSimulation Reference\n\n\n#\n\n\nEventSimulation\n \n \nModule\n.\n\n\nEventSimulation is an event-based discrete event simulation engine.\n\n\nsource\n\n\n#\n\n\nEventSimulation.Action\n \n \nType\n.\n\n\nStructure holding an information that \nwhat\n should be executed by scheduler at time \nwhen\n; \nwhat\n should accept one argument of type \nScheduler\n.\n\n\nsource\n\n\n#\n\n\nEventSimulation.AbstractState\n \n \nType\n.\n\n\nAbstract type for holding state of the simulation\n\n\nsource\n\n\n#\n\n\nEventSimulation.EmptyState\n \n \nType\n.\n\n\nSimplest concrete type implementing \nAbstractState\n that does not hold any data\n\n\nsource\n\n\n#\n\n\nEventSimulation.Scheduler\n \n \nType\n.\n\n\nHolds information about current simulation state Contains the following fields:\n\n\n\n\nnow\n         current simulation time\n\n\nevent_queue\n priority queue of \nActions\n planned to be executed\n\n\nstate\n       user defined subtype of \nAbstractState\n of the simulation\n\n\nmonitor\n     function that is called before event is triggered               must accept two arguments \nScheduler\n and \n\u0394\n, a difference               between time of event to be executed and time of last executed event\n\n\n\n\nIf two \nAction\ns have identical \nwhen\n time in \nevent_queue\n then the order of their execution is undefined\n\n\nWhen \nmonitor\n is executed the event to happen is still on \nevent_queue\n, but time is updated to time when the event is to be executed (i.e. \nmonitor\n sees the state of the simulation just before the event is triggered). Therefore for calculating summary statistics \nmonitor\n may assume that the simulation spent \n\u0394\n time in this state. Function \nmonitor\n should not modify \nevent_queue[1]\n as EventSimulation assumes that the event to be triggerd after \nmonitor\n executes will not be modified.\n\n\nsource\n\n\n#\n\n\nEventSimulation.register!\n \n \nFunction\n.\n\n\nregister!(s, what, \u0394)\n\n\n\n\nPut \nwhat\n at time \ns.now+\u0394\n to \ns.event_queue\n. \nwhat\n must accept exactly one argument of type \nScheduler\n. Returns inserted \nAction\n.\n\n\nsource\n\n\n#\n\n\nEventSimulation.repeat_register!\n \n \nFunction\n.\n\n\nrepeat_register!(s, what, interval)\n\n\n\n\nPut \nwhat\n to \ns.event_queue\n repeatedly in time intervals specified by \ninterval\n function, which must accept one argument of type \nScheduler\n. \nwhat\n must accept exactly one argument of type \nScheduler\n. Returns first inserted \nAction\n. Calling \nterminate!\n in function \ninterval\n will not stop the simulation.\n\n\nsource\n\n\n#\n\n\nEventSimulation.bulk_register!\n \n \nFunction\n.\n\n\nbulk_register!(s, who, what, \u0394, randomize)\n\n\n\n\nPut event at time \ns.now+\u0394\n to \ns.event_queue\n that will execute \nwhat(scheduler, w)\n for all \nw\n in \nwho\n. If \nrandomize\n is \nfalse\n then \nwho\n is traversed in natural order otherwise it is traversed in random order. \nwhat\n must accept exactly two arguments of type \nScheduler\n and \ntypeof(who)\n. Returns inserted bulk \nAction\n.\n\n\nFunction is designed to efficiently handle case when the same action has to be executed at the same simulation time by many agents.\n\n\nsource\n\n\n#\n\n\nEventSimulation.repeat_bulk_register!\n \n \nFunction\n.\n\n\nrepeat_bulk_register!(s, who, what, \u0394, randomize)\n\n\n\n\nRepeat \nbulk_register!\n at time intervals specified by \ninterval\n function, which must accept \nScheduler\n argument. \nwhat\n must accept exactly two arguments of type \nScheduler\n and \ntypeof(who)\n. Returns first inserted bulk \nAction\n. Calling \nterminate!\n in function \ninterval\n will not stop the simulation.\n\n\nsource\n\n\n#\n\n\nEventSimulation.interrupt!\n \n \nFunction\n.\n\n\ninterrupt!(s, a)\n\n\n\n\nFirst occurence of action \na\n is replaced by no-op in event queue. This way there is no need to fix heap in this operation and it is fast. Returns \ntrue\n if \na\n was found in queue and \nfalse\n otherwise.\n\n\nsource\n\n\n#\n\n\nEventSimulation.terminate!\n \n \nFunction\n.\n\n\nterminate!(s)\n\n\n\n\nEmpties \ns.event_queue\n which will lead to termination of simulation unless it is refilled before execution returns to \ngo!\n. Useful for event-triggered termination of simulation.\n\n\nsource\n\n\n#\n\n\nEventSimulation.go!\n \n \nFunction\n.\n\n\ngo!(s, until)\n\n\n\n\nRuns simulation defined by \ns\n until \ns.now\n is greater or equal than \nuntil\n or \ns.event_queue\n is empty (i.e. nothing is left to be done). By default \nuntil\n equals \nInf\n.\n\n\nsource\n\n\n#\n\n\nEventSimulation.AbstractReservoir\n \n \nType\n.\n\n\nAbstract class for reservoirs. \nSimQueue\n and \nSimResource\n are concrete types implementing it.\n\n\nsource\n\n\n#\n\n\nEventSimulation.SimResource\n \n \nType\n.\n\n\nResource type for holding numeric values (like amount of liquid). It stores current \nquantity\n of matter and its allowed \nlo\n and \nhi\n amounts. Servers can get matter from the resource with optional maximum number of requests pending for fulfillment.\n\n\nFields:\n\n\n\n\nquantiy\n       current quantity in resource\n\n\nlo\n            minimum quantity of resource\n\n\nhi\n            maximum quantity of resource\n\n\nfifo_requests\n if \ntrue\n \nrequests\n is FIFO, otherwise LIFO\n\n\nmax_requests\n  maximum \nrequests\n size\n\n\nrequests\n      vector of request and requested quantity\n\n\n\n\nFunctions in \nrequests\n must accept one argument \nScheduler\n, so they should know the amount they requested. When resource arrives to a queue there is a try to immediately dispatch it to pending requests. When new request arrives there is a try to immediately fulfill it.\n\n\nInitially an empty \nSimResource\n with no requests is constructed. Initial \nquantity\n, \nlo\n and \nhi\n may be provided. By default \nSimResource\n is empty, and has minimum quantity of zero and unbounded maximum.\n\n\nsource\n\n\n#\n\n\nEventSimulation.ResourceRequest\n \n \nType\n.\n\n\nInternal structure that remembers that \nquantity\n was requested by \nrequest\n.\n\n\nsource\n\n\n#\n\n\nEventSimulation.SimQueue\n \n \nType\n.\n\n\nSimQueue type for holding arbitrary objects \nO\n. It allows objects to be waiting in a queue with optional maximum queue size. Servers can get objects from the queue with optional maximum number of requests pending for fulfillment.\n\n\nFields:\n\n\n\n\nfifo_queue\n    if \ntrue\n \nqueue\n is FIFO, otherwise LIFO\n\n\nmax_queue\n     maximum \nqueue\n size\n\n\nqueue\n         vector of objects in a queue\n\n\nfifo_requests\n if \ntrue\n \nrequests\n is FIFO, otherwise LIFO\n\n\nmax_requests\n  maximum \nrequests\n size\n\n\nrequests\n      vector of request functions\n\n\n\n\nFunctions in \nrequests\n must accept two arguments \nScheduler\n and \nO\n. When \nO\n arrives to a queue there is a try to immediately feed it to pending requests. When new request arrives there is a try to immediately provide it with \nO\n.\n\n\nInitially an empty \nSimQueue\n with no requests is constructed. By default \nqueue\n and \nrequests\n have FIFO policy and are unbounded.\n\n\nsource\n\n\n#\n\n\nEventSimulation.request!\n \n \nFunction\n.\n\n\nrequest!(s, r, quantity, request)\nrequest!(s, q, request)\n\n\n\n\nFunction used to register request for resource in \nSimResource\n or object from \nSimQueue\n.\n\n\nIn \nSimResource\n requested \nquantity\n must be provided and \nrequest\n accepts only \nScheduler\n argument (it must know what it wanted). Returns tuple of:\n\n\n\n\ntrue\n if successfull and \nfalse\n when too many requests were made\n\n\nResourceRequest\n object created\n\n\n\n\nIn \nSimQueue\n function \nrequest\n must accept two arguments \nScheduler\n and object. Returns \ntrue\n if successfull and \nfalse\n when too many requests were made.\n\n\nsource\n\n\n#\n\n\nEventSimulation.waive!\n \n \nFunction\n.\n\n\nwaive!(r, res_request)\nwaive!(q, request)\n\n\n\n\nAllows to remove first occurence that would be served of \nres_request\n from \nSimResource\n or \nrequest\n from \nSimQueue\n.\n\n\nReturns \ntrue\n on success and \nfalse\n if \nres_request\n or \nrequest\n respectively was not found.\n\n\nsource\n\n\n#\n\n\nEventSimulation.provide!\n \n \nFunction\n.\n\n\nprovide!(s, r, quantity)\nprovide!(s, q, object)\n\n\n\n\nAllows to fill \nSimResource\n with \nquantity\n or \nSimQueue\n with \nobject\n.\n\n\nIn \nSimResource\n changes the balance of \nr.quantity\n. Given quantity may be any number, but the balance of \nSimResource\n will be changed only in \nlo\n-\nhi\n range. Returns the actual change in \nSimResource\n balance.\n\n\nIn \nSimQueue\n adds \nobject\n to \nq.queue\n. Returns \ntrue\n on success and \nfalse\n if there were too many objects in queue already.\n\n\nsource\n\n\n#\n\n\nEventSimulation.withdraw!\n \n \nFunction\n.\n\n\nwithdraw!(q, object)\n\n\n\n\nAllows to remove first occurrence that would be served of \nobject\n from \nSimQueue\n.\n\n\nReturns \ntrue\n on success and \nfalse\n if \nobject\n was not found.\n\n\nsource\n\n\n#\n\n\nEventSimulation.PriorityTime\n \n \nType\n.\n\n\nSubtype of \nReal\n defining a lexicographically comparable pair of \nReal\n. It is designed to be used by \nScheduler\n where standard real numbers run to a problem of undefined order of undefined order of removal from priority queue.\n\n\nPriorityTime\n two fields \ntime\n and \npriority\n may have different types, but both have to be subtypes of \nReal\n. \npriority\n should be used to determine order of execution of \nAction\ns that have the same time. Two actions with identical \ntime\n and \npriority\n have undefined oreder of execution so this should be avoided.\n\n\nPriorityTime\n type has defined lexicographic order and \n+\n, \n-\n. It is immutable, has a custom \nhash\n function and conversions from \nReal\n types.\n\n\nsource", 
            "title": "Reference"
        }, 
        {
            "location": "/reference/#eventsimulation-reference", 
            "text": "#  EventSimulation     Module .  EventSimulation is an event-based discrete event simulation engine.  source  #  EventSimulation.Action     Type .  Structure holding an information that  what  should be executed by scheduler at time  when ;  what  should accept one argument of type  Scheduler .  source  #  EventSimulation.AbstractState     Type .  Abstract type for holding state of the simulation  source  #  EventSimulation.EmptyState     Type .  Simplest concrete type implementing  AbstractState  that does not hold any data  source  #  EventSimulation.Scheduler     Type .  Holds information about current simulation state Contains the following fields:   now          current simulation time  event_queue  priority queue of  Actions  planned to be executed  state        user defined subtype of  AbstractState  of the simulation  monitor      function that is called before event is triggered               must accept two arguments  Scheduler  and  \u0394 , a difference               between time of event to be executed and time of last executed event   If two  Action s have identical  when  time in  event_queue  then the order of their execution is undefined  When  monitor  is executed the event to happen is still on  event_queue , but time is updated to time when the event is to be executed (i.e.  monitor  sees the state of the simulation just before the event is triggered). Therefore for calculating summary statistics  monitor  may assume that the simulation spent  \u0394  time in this state. Function  monitor  should not modify  event_queue[1]  as EventSimulation assumes that the event to be triggerd after  monitor  executes will not be modified.  source  #  EventSimulation.register!     Function .  register!(s, what, \u0394)  Put  what  at time  s.now+\u0394  to  s.event_queue .  what  must accept exactly one argument of type  Scheduler . Returns inserted  Action .  source  #  EventSimulation.repeat_register!     Function .  repeat_register!(s, what, interval)  Put  what  to  s.event_queue  repeatedly in time intervals specified by  interval  function, which must accept one argument of type  Scheduler .  what  must accept exactly one argument of type  Scheduler . Returns first inserted  Action . Calling  terminate!  in function  interval  will not stop the simulation.  source  #  EventSimulation.bulk_register!     Function .  bulk_register!(s, who, what, \u0394, randomize)  Put event at time  s.now+\u0394  to  s.event_queue  that will execute  what(scheduler, w)  for all  w  in  who . If  randomize  is  false  then  who  is traversed in natural order otherwise it is traversed in random order.  what  must accept exactly two arguments of type  Scheduler  and  typeof(who) . Returns inserted bulk  Action .  Function is designed to efficiently handle case when the same action has to be executed at the same simulation time by many agents.  source  #  EventSimulation.repeat_bulk_register!     Function .  repeat_bulk_register!(s, who, what, \u0394, randomize)  Repeat  bulk_register!  at time intervals specified by  interval  function, which must accept  Scheduler  argument.  what  must accept exactly two arguments of type  Scheduler  and  typeof(who) . Returns first inserted bulk  Action . Calling  terminate!  in function  interval  will not stop the simulation.  source  #  EventSimulation.interrupt!     Function .  interrupt!(s, a)  First occurence of action  a  is replaced by no-op in event queue. This way there is no need to fix heap in this operation and it is fast. Returns  true  if  a  was found in queue and  false  otherwise.  source  #  EventSimulation.terminate!     Function .  terminate!(s)  Empties  s.event_queue  which will lead to termination of simulation unless it is refilled before execution returns to  go! . Useful for event-triggered termination of simulation.  source  #  EventSimulation.go!     Function .  go!(s, until)  Runs simulation defined by  s  until  s.now  is greater or equal than  until  or  s.event_queue  is empty (i.e. nothing is left to be done). By default  until  equals  Inf .  source  #  EventSimulation.AbstractReservoir     Type .  Abstract class for reservoirs.  SimQueue  and  SimResource  are concrete types implementing it.  source  #  EventSimulation.SimResource     Type .  Resource type for holding numeric values (like amount of liquid). It stores current  quantity  of matter and its allowed  lo  and  hi  amounts. Servers can get matter from the resource with optional maximum number of requests pending for fulfillment.  Fields:   quantiy        current quantity in resource  lo             minimum quantity of resource  hi             maximum quantity of resource  fifo_requests  if  true   requests  is FIFO, otherwise LIFO  max_requests   maximum  requests  size  requests       vector of request and requested quantity   Functions in  requests  must accept one argument  Scheduler , so they should know the amount they requested. When resource arrives to a queue there is a try to immediately dispatch it to pending requests. When new request arrives there is a try to immediately fulfill it.  Initially an empty  SimResource  with no requests is constructed. Initial  quantity ,  lo  and  hi  may be provided. By default  SimResource  is empty, and has minimum quantity of zero and unbounded maximum.  source  #  EventSimulation.ResourceRequest     Type .  Internal structure that remembers that  quantity  was requested by  request .  source  #  EventSimulation.SimQueue     Type .  SimQueue type for holding arbitrary objects  O . It allows objects to be waiting in a queue with optional maximum queue size. Servers can get objects from the queue with optional maximum number of requests pending for fulfillment.  Fields:   fifo_queue     if  true   queue  is FIFO, otherwise LIFO  max_queue      maximum  queue  size  queue          vector of objects in a queue  fifo_requests  if  true   requests  is FIFO, otherwise LIFO  max_requests   maximum  requests  size  requests       vector of request functions   Functions in  requests  must accept two arguments  Scheduler  and  O . When  O  arrives to a queue there is a try to immediately feed it to pending requests. When new request arrives there is a try to immediately provide it with  O .  Initially an empty  SimQueue  with no requests is constructed. By default  queue  and  requests  have FIFO policy and are unbounded.  source  #  EventSimulation.request!     Function .  request!(s, r, quantity, request)\nrequest!(s, q, request)  Function used to register request for resource in  SimResource  or object from  SimQueue .  In  SimResource  requested  quantity  must be provided and  request  accepts only  Scheduler  argument (it must know what it wanted). Returns tuple of:   true  if successfull and  false  when too many requests were made  ResourceRequest  object created   In  SimQueue  function  request  must accept two arguments  Scheduler  and object. Returns  true  if successfull and  false  when too many requests were made.  source  #  EventSimulation.waive!     Function .  waive!(r, res_request)\nwaive!(q, request)  Allows to remove first occurence that would be served of  res_request  from  SimResource  or  request  from  SimQueue .  Returns  true  on success and  false  if  res_request  or  request  respectively was not found.  source  #  EventSimulation.provide!     Function .  provide!(s, r, quantity)\nprovide!(s, q, object)  Allows to fill  SimResource  with  quantity  or  SimQueue  with  object .  In  SimResource  changes the balance of  r.quantity . Given quantity may be any number, but the balance of  SimResource  will be changed only in  lo - hi  range. Returns the actual change in  SimResource  balance.  In  SimQueue  adds  object  to  q.queue . Returns  true  on success and  false  if there were too many objects in queue already.  source  #  EventSimulation.withdraw!     Function .  withdraw!(q, object)  Allows to remove first occurrence that would be served of  object  from  SimQueue .  Returns  true  on success and  false  if  object  was not found.  source  #  EventSimulation.PriorityTime     Type .  Subtype of  Real  defining a lexicographically comparable pair of  Real . It is designed to be used by  Scheduler  where standard real numbers run to a problem of undefined order of undefined order of removal from priority queue.  PriorityTime  two fields  time  and  priority  may have different types, but both have to be subtypes of  Real .  priority  should be used to determine order of execution of  Action s that have the same time. Two actions with identical  time  and  priority  have undefined oreder of execution so this should be avoided.  PriorityTime  type has defined lexicographic order and  + ,  - . It is immutable, has a custom  hash  function and conversions from  Real  types.  source", 
            "title": "EventSimulation Reference"
        }
    ]
}